name: tgo-suite

services:
  # Postgres with pgvector extension for RAG
  postgres:
    image: pgvector/pgvector:pg16
    container_name: tgo-postgres
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-tgo}
      POSTGRES_USER: ${POSTGRES_USER:-tgo}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-tgo}
    # ports:
      # - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Redis cache
  redis:
    image: redis:7-alpine
    container_name: tgo-redis
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - ./data/redis:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # WuKongIM service
  wukongim:
    image: registry.cn-shanghai.aliyuncs.com/wukongim/wukongim:v2.2.2-20251013-dev
    container_name: tgo-wukongim
    env_file:
      - ./envs/wukongim.env
    volumes:
      - ./data/wukongim:/root/wukongim
    ports:
      - "5100:5100"   # tcp
      - "5200:5200"   # websocket
      # - "5300:5300"   # admin
      # - "11110:11110" # cluster
    healthcheck:
      test: ["CMD-SHELL", "wget -q -Y off -O /dev/null http://localhost:5001/health > /dev/null 2>&1 || exit 1"]
      interval: 10s
      timeout: 10s
      retries: 3
    restart: always
  # Kafka (single-node KRaft)
  kafka:
    image: apache/kafka:4.1.1
    container_name: tgo-api-kafka
    environment:
      - KAFKA_NODE_ID=1
      - KAFKA_PROCESS_ROLES=broker,controller
      - KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,CONTROLLER:PLAINTEXT
      - KAFKA_LISTENERS=INTERNAL://:9092,EXTERNAL://:9094,CONTROLLER://:9093
      - KAFKA_ADVERTISED_LISTENERS=INTERNAL://kafka:9092,EXTERNAL://localhost:9094
      - KAFKA_INTER_BROKER_LISTENER_NAME=INTERNAL
      - KAFKA_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_CONTROLLER_QUORUM_VOTERS=1@kafka:9093
      - KAFKA_LOG_DIRS=/var/lib/kafka/data
      - KAFKA_NUM_PARTITIONS=1
      - KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1
      - KAFKA_TRANSACTION_STATE_LOG_MIN_ISR=1
      - KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR=1
      - KAFKA_AUTO_CREATE_TOPICS_ENABLE=true
      - CLUSTER_ID=MkU3OEVBNTcwNTJENDM2Qk
    volumes:
      - ./data/kafka/data:/var/lib/kafka/data
    healthcheck:
      test: ["CMD", "bash", "-c", "/opt/kafka/bin/kafka-topics.sh --bootstrap-server localhost:9092 --list || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
    restart: unless-stopped

  # RAG Celery worker
  tgo-rag-worker:
    image: ghcr.io/tgoai/tgo/tgo-rag:latest
    container_name: tgo-rag-worker
    env_file:
      - ./.env
      - ./envs/tgo-rag.env
    volumes:
      - ./data/tgo-rag/uploads:/app/uploads
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      tgo-rag:
        condition: service_started
    command: >
      sh -c "celery -A src.rag_service.tasks.celery_app worker --loglevel=info"
    restart: unless-stopped

  # RAG Celery beat (scheduler)
  tgo-rag-beat:
    image: ghcr.io/tgoai/tgo/tgo-rag:latest
    container_name: tgo-rag-beat
    env_file:
      - ./.env
      - ./envs/tgo-rag.env
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      tgo-rag:
        condition: service_started
    command: >
      sh -c "celery -A src.rag_service.tasks.celery_app beat --loglevel=info"
    restart: unless-stopped

  # RAG Flower (Celery monitoring UI)
  tgo-rag-flower:
    image: ghcr.io/tgoai/tgo/tgo-rag:latest
    container_name: tgo-rag-flower
    env_file:
      - ./.env
      - ./envs/tgo-rag.env
    depends_on:
      redis:
        condition: service_healthy
      tgo-rag:
        condition: service_started
    command: >
      sh -c "celery -A src.rag_service.tasks.celery_app flower --port=5555"
    restart: unless-stopped

  # RAG service
  tgo-rag:
    image: ghcr.io/tgoai/tgo/tgo-rag:latest
    container_name: tgo-rag
    env_file:
      - ./.env
      - ./envs/tgo-rag.env
    depends_on:
      - postgres
      - redis
    volumes:
      - ./data/tgo-rag/uploads:/app/uploads
    restart: unless-stopped


  # AI service
  tgo-ai:
    image: ghcr.io/tgoai/tgo/tgo-ai:latest
    container_name: tgo-ai
    env_file:
      - ./.env
      - ./envs/tgo-ai.env
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
      tgo-rag:
        condition: service_started
    command: >
      sh -c "alembic upgrade head && uvicorn app.main:app --host 0.0.0.0 --port 8081"
    restart: unless-stopped

  # API service
  tgo-api:
    image: ghcr.io/tgoai/tgo/tgo-api:latest
    container_name: tgo-api
    env_file:
      - ./envs/tgo-api.env
      - ./.env
    depends_on:
      - kafka
      - tgo-ai
      - postgres
      - redis
    volumes:
      # Persist API uploads (chat files, platform logos, etc.) under unified data directory
      - ./data/tgo-api/uploads:/app/uploads
    restart: unless-stopped

  # Platform service
  tgo-platform:
    image: ghcr.io/tgoai/tgo/tgo-platform:latest
    container_name: tgo-platform
    env_file:
      - ./.env
      - ./envs/tgo-platform.env
    depends_on:
      - tgo-api
      - postgres
      - redis
      - wukongim
    restart: unless-stopped

  # Customer service web (React build -> nginx)
  tgo-web:
    image: ghcr.io/tgoai/tgo/tgo-web:latest
    container_name: tgo-web
    environment:
      # Runtime environment variables (injected by docker-entrypoint.sh)
      API_BASE_URL: ${API_BASE_URL:-http://tgo-api:8000}
      DEBUG_MODE: ${DEBUG_MODE:-false}
      # Frontend environment variables for Nginx
      VITE_WIDGET_PREVIEW_URL: ${VITE_WIDGET_PREVIEW_URL:-http://localhost/widget}
    env_file:
      - ./envs/tgo-web.env
    volumes:
      - ./scripts/inject-frontend-env.sh:/docker-entrypoint.d/05-inject-frontend-env.sh:ro
    restart: unless-stopped

  # Widget app (React build -> nginx)
  tgo-widget-app:
    image: ghcr.io/tgoai/tgo/tgo-widget-app:latest
    container_name: tgo-widget-app
    environment:
      # Runtime environment variables (injected by docker-entrypoint.sh)
      API_BASE_URL: ${API_BASE_URL:-http://tgo-api:8000}
    env_file:
      - ./envs/tgo-widget-app.env
    restart: unless-stopped

  # Nginx Reverse Proxy for Domain and SSL Management
  nginx:
    image: nginx:alpine
    container_name: tgo-nginx
    ports:
      - "${NGINX_PORT:-80}:80"
      - "${NGINX_SSL_PORT:-443}:443"
    volumes:
      # Nginx configuration
      - ./data/nginx/conf.d:/etc/nginx/conf.d:ro
      - ./data/nginx/ssl:/etc/nginx/ssl:ro
      # Certbot challenge directory
      - ./data/certbot/www:/var/www/certbot:ro
      # Certbot configuration
      - ./data/certbot/conf:/etc/letsencrypt:ro
    depends_on:
      - tgo-web
      - tgo-widget-app
      - tgo-api
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "-q", "-O", "/dev/null", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # Certbot for Let's Encrypt certificate management
  certbot:
    image: certbot/certbot:latest
    container_name: tgo-certbot
    volumes:
      - ./data/certbot/conf:/etc/letsencrypt
      - ./data/certbot/www:/var/www/certbot
      - ./data/certbot/logs:/var/log/letsencrypt
    entrypoint: /bin/sh -c "trap exit TERM; while :; do certbot renew --quiet; sleep 12h & wait $${!}; done"
    restart: unless-stopped
    profiles:
      - ssl-auto

