#!/usr/bin/env bash
set -euo pipefail

# Move to repo root
cd "$(dirname "$0")"

MAIN_COMPOSE_IMAGE="docker-compose.yml"
MAIN_COMPOSE_SOURCE="docker-compose.source.yml"
MAIN_COMPOSE_CN="docker-compose.cn.yml"
TOOLS_COMPOSE="docker-compose.tools.yml"
ENV_FILE=".env"
CONFIG_FILE="./data/.tgo-install-mode"

# Global flag for China mirror support
USE_CN_MIRROR=false

usage() {
  cat <<'EOF'
Usage: ./tgo.sh <command> [options]

Commands:
  help                                Show this help message
  install [--source] [--cn]           Deploy all services (migrate, start; default: use pre-built images)
  upgrade [--source] [--cn]           Upgrade to latest version (remembers install mode if no options provided)
  uninstall [--source] [--cn]         Stop and remove all services (prompts for data deletion)
  service <start|stop|remove> [--source] [--cn]
                                      Start/stop/remove core services
  tools <start|stop>                  Start/stop debug tools (kafka-ui, adminer)
  build [--source] [--cn] <service>   Rebuild specific service from source (api|rag|ai|platform|web|widget|all)
  config <subcommand> [args]          Configure domains and SSL certificates

Config Subcommands:
  web_domain <domain>                 Set web service domain (e.g., www.talkgo.cn)
  widget_domain <domain>              Set widget service domain (e.g., widget.talkgo.cn)
  api_domain <domain>                 Set API service domain (e.g., api.talkgo.cn)
  ssl_mode <auto|manual|none>         Set SSL mode (auto=Let's Encrypt, manual=custom, none=no SSL)
  ssl_email <email>                   Set Let's Encrypt email for certificate renewal
  ssl_manual <cert> <key> [domain]    Install manual SSL certificate
  setup_letsencrypt                   Setup Let's Encrypt certificates for all domains
  apply                               Regenerate Nginx configuration
  show                                Show current domain configuration

Options:
  --source    Build and run services from local source code (repos/)
  --cn        Use China mirrors (Alibaba Cloud ACR for images, Gitee for git repos)

Notes:
  - By default, commands use image-based deployment (docker-compose.yml, images from GHCR).
  - Pass --source to build and run services from local source (docker-compose.yml + docker-compose.source.yml).
  - Pass --cn to use China-based mirrors for faster access in mainland China.
  - Options can be combined: ./tgo.sh install --source --cn

Domain Configuration Examples:
  ./tgo.sh config web_domain www.talkgo.cn
  ./tgo.sh config widget_domain widget.talkgo.cn
  ./tgo.sh config api_domain api.talkgo.cn
  ./tgo.sh config ssl_mode auto
  ./tgo.sh config ssl_email admin@talkgo.cn
  ./tgo.sh config setup_letsencrypt
  ./tgo.sh config show

Upgrade Command:
  - The upgrade command remembers the mode used during install (saved in ./data/.tgo-install-mode)
  - If you provide --source or --cn flags, they will override the saved configuration
  - Examples:
    • ./tgo.sh install --cn          → ./tgo.sh upgrade (auto-uses --cn)
    • ./tgo.sh install --source      → ./tgo.sh upgrade (auto-uses --source)
    • ./tgo.sh upgrade --cn          → Override to use --cn for this upgrade
EOF
}

# Save install mode configuration
save_install_mode() {
  local mode="$1"
  local use_cn="$2"

  # Ensure data directory exists
  mkdir -p "$(dirname "$CONFIG_FILE")"

  # Write configuration
  cat > "$CONFIG_FILE" << EOF
# TGO Install Mode Configuration
# Auto-generated by ./tgo.sh install
# This file is used by ./tgo.sh upgrade to remember your deployment preferences

USE_SOURCE=$( [ "$mode" = "source" ] && echo "true" || echo "false" )
USE_CN=$( [ "$use_cn" = "true" ] && echo "true" || echo "false" )
EOF

  echo "[INFO] Saved install mode to $CONFIG_FILE"
}

# Load install mode configuration
load_install_mode() {
  if [ ! -f "$CONFIG_FILE" ]; then
    echo "[WARN] No saved install mode found at $CONFIG_FILE"
    echo "[WARN] Using default mode: image-based deployment from GHCR"
    echo "false false"  # mode=image, use_cn=false
    return
  fi

  # Source the config file
  local use_source="false"
  local use_cn="false"

  # shellcheck disable=SC1090
  source "$CONFIG_FILE"

  # Convert to mode string
  local mode="image"
  if [ "${USE_SOURCE:-false}" = "true" ]; then
    mode="source"
  fi

  local cn_flag="false"
  if [ "${USE_CN:-false}" = "true" ]; then
    cn_flag="true"
  fi

  echo "$mode $cn_flag"
}

# Note: docker-compose.cn.yml is now a static file in the repository
# (no longer auto-generated)

ensure_env_files() {
  if [ ! -f "$ENV_FILE" ]; then
    cp .env.example "$ENV_FILE"
    echo "[INFO] Created .env from .env.example. Edit it if needed."
  fi

  if [ ! -d "envs" ] && [ -d "envs.docker" ]; then
    cp -R "envs.docker" "envs"
    echo "[INFO] Created envs/ from envs.docker."
  fi
}

ensure_api_secret_key() {
  local file="envs/tgo-api.env"
  [ -f "$file" ] || { echo "[WARN] $file not found; skipping SECRET_KEY generation"; return 0; }
  local placeholder="ad6b1be1e4f9d2b03419e0876d0d2a19c647c7ef1dd1d2d9d3f98a09b7b1c0e7"
  local current
  current=$(grep -E '^SECRET_KEY=' "$file" | head -n1 | cut -d= -f2- || true)
  if [ -z "$current" ] || [ "$current" = "$placeholder" ] || [ "$current" = "changeme" ] || [ ${#current} -lt 32 ]; then
    local newkey
    if command -v openssl >/dev/null 2>&1; then
      newkey=$(openssl rand -hex 32)
    elif command -v python3 >/dev/null 2>&1; then
      newkey=$(python3 - <<'PY'
import secrets; print(secrets.token_hex(32))
PY
)
    elif command -v python >/dev/null 2>&1; then
      newkey=$(python - <<'PY'
import secrets; print(secrets.token_hex(32))
PY
)
    else
      newkey=$(dd if=/dev/urandom bs=32 count=1 2>/dev/null | xxd -p -c 64 2>/dev/null || date +%s | shasum -a 256 | awk '{print $1}' | cut -c1-64)
    fi
    local tmp="${file}.tmp"
    if grep -qE '^SECRET_KEY=' "$file"; then
      awk -v nk="$newkey" 'BEGIN{FS=OFS="="} /^SECRET_KEY=/{print "SECRET_KEY",nk; next} {print $0}' "$file" > "$tmp" && mv "$tmp" "$file"
    else
      printf "\nSECRET_KEY=%s\n" "$newkey" >> "$file"
    fi
    echo "[INFO] Generated new SECRET_KEY for tgo-api."
  else
    echo "[INFO] SECRET_KEY already set and valid."
  fi
}

wait_for_postgres() {
  local compose_file_args=${1:-"-f $MAIN_COMPOSE_IMAGE"}
  echo "[INFO] Waiting for Postgres to be ready..."
  local retries=60
  local user="${POSTGRES_USER:-tgo}"
  local db="${POSTGRES_DB:-tgo}"
  for _ in $(seq 1 "$retries"); do
    if docker compose --env-file "$ENV_FILE" $compose_file_args exec -T postgres pg_isready -U "$user" -d "$db" >/dev/null 2>&1; then
      echo "[INFO] Postgres is ready."
      return 0
    fi
    sleep 2
  done
  echo "[ERROR] Postgres was not ready in time."
  return 1
}

cmd_install() {
  local mode="image"
  local use_cn=false

  # Parse arguments (support --source and --cn in any order)
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --source)
        mode="source"
        shift
        ;;
      --cn)
        use_cn=true
        USE_CN_MIRROR=true
        shift
        ;;
      *)
        echo "[ERROR] Unknown argument to install: $1" >&2
        usage
        exit 1
        ;;
    esac
  done

  ensure_env_files
  ensure_api_secret_key

  # Save install mode for future upgrade commands
  save_install_mode "$mode" "$use_cn"

  local compose_file_args="-f $MAIN_COMPOSE_IMAGE"
  if [ "$mode" = "source" ]; then
    if [ ! -f "$MAIN_COMPOSE_SOURCE" ]; then
      echo "[ERROR] $MAIN_COMPOSE_SOURCE not found. Cannot run in --source mode." >&2
      exit 1
    fi
    compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_SOURCE"
    echo "[INFO] Deployment mode: SOURCE (building images from local repos)."
  else
    if [ "$use_cn" = true ]; then
      compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_CN"
      echo "[INFO] Deployment mode: IMAGE (using pre-built images from Alibaba Cloud ACR)."
    else
      echo "[INFO] Deployment mode: IMAGE (using pre-built images from GHCR)."
    fi
  fi

  if [ "$mode" = "source" ]; then
    echo "[INFO] Building application images from source..."
    docker compose --env-file "$ENV_FILE" $compose_file_args build
  else
    if [ "$use_cn" = true ]; then
      echo "[INFO] Skipping local image build; Docker will pull images from Alibaba Cloud ACR."
    else
      echo "[INFO] Skipping local image build; Docker will pull images from GHCR."
    fi
  fi

  # Create data directories with correct permissions
  echo "[INFO] Creating data directories..."

  # Determine the target user for directory ownership
  # If running with sudo, use the actual user; otherwise use current user
  if [ -n "${SUDO_USER:-}" ]; then
    TARGET_USER="$SUDO_USER"
    TARGET_UID=$(id -u "$SUDO_USER")
    TARGET_GID=$(id -g "$SUDO_USER")
  else
    TARGET_USER="${USER:-$(whoami)}"
    TARGET_UID=$(id -u)
    TARGET_GID=$(id -g)
  fi

  # List of data directories to create
  DATA_DIRS=(
    "./data/postgres"
    "./data/redis"
    "./data/wukongim"
    "./data/kafka/data"
    "./data/tgo-rag/uploads"
    "./data/tgo-api/uploads",
    "./data/nginx"
  )

  # Create directories and set permissions
  for dir in "${DATA_DIRS[@]}"; do
    # Check if directory exists and is writable
    if [ -d "$dir" ] && [ -w "$dir" ]; then
      echo "  ✓ $dir (already exists and writable)"
      continue
    fi

    # Directory doesn't exist or isn't writable - need to create/fix it
    if [ ! -d "$dir" ]; then
      echo "  Creating $dir..."
      mkdir -p "$dir"

      # Set ownership and permissions only for newly created directories
      if [ "$(id -u)" -eq 0 ] && [ "$TARGET_UID" -ne 0 ]; then
        # Running as root, set to actual user
        chown -R "$TARGET_UID:$TARGET_GID" "$dir"
        chmod -R 755 "$dir"
        echo "  Set ownership to $TARGET_USER ($TARGET_UID:$TARGET_GID)"
      elif [ "$(id -u)" -eq 0 ]; then
        # Running as root, set to Docker default user
        chown -R 1000:1000 "$dir"
        chmod -R 755 "$dir"
        echo "  Set ownership to 1000:1000 (Docker default)"
      else
        # Running as normal user, just set permissions
        chmod -R 755 "$dir" 2>/dev/null || echo "  ⚠ Created but cannot set permissions (may need sudo)"
      fi
    else
      # Directory exists but not writable
      echo "  ⚠ $dir exists but not writable"
      if [ "$(id -u)" -eq 0 ]; then
        # We're root, we can fix it
        chown -R "$TARGET_UID:$TARGET_GID" "$dir" 2>/dev/null || chown -R 1000:1000 "$dir"
        chmod -R 755 "$dir"
        echo "  Fixed permissions"
      else
        echo "  ⚠ Run with sudo to fix permissions, or manually run: sudo chown -R \$USER:$TARGET_GID $dir"
      fi
    fi
  done

  echo "[INFO] Data directories created and permissions set."

  # Initialize domain configuration and generate Nginx config
  echo "[INFO] Initializing Nginx configuration..."
  ensure_domain_config
  regenerate_nginx_config

  echo "[INFO] Starting core infrastructure (postgres, redis, kafka, wukongim)..."
  docker compose --env-file "$ENV_FILE" $compose_file_args up -d postgres redis kafka wukongim

  wait_for_postgres "$compose_file_args"

  echo "[INFO] Running Alembic migrations for tgo-rag..."
  docker compose --env-file "$ENV_FILE" $compose_file_args run --rm  tgo-rag alembic upgrade head

  echo "[INFO] Running Alembic migrations for tgo-ai..."
  docker compose --env-file "$ENV_FILE" $compose_file_args run --rm tgo-ai alembic upgrade head

  echo "[INFO] Running Alembic migrations for tgo-api..."
  docker compose --env-file "$ENV_FILE" $compose_file_args run --rm tgo-api alembic upgrade head

  echo "[INFO] Running Alembic migrations for tgo-platform..."
  docker compose --env-file "$ENV_FILE" $compose_file_args run --rm -e PYTHONPATH=. tgo-platform alembic upgrade head

  echo "[INFO] Starting all core services..."
  docker compose --env-file "$ENV_FILE" $compose_file_args up -d
  echo "[INFO] All services are starting. Use 'docker compose ps' to inspect status."
}

cmd_uninstall() {
  local mode="image"
  local use_cn=false

  # Parse arguments (support --source and --cn in any order)
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --source)
        mode="source"
        shift
        ;;
      --cn)
        use_cn=true
        USE_CN_MIRROR=true
        shift
        ;;
      *)
        echo "[ERROR] Unknown argument to uninstall: $1" >&2
        usage
        exit 1
        ;;
    esac
  done

  ensure_env_files

  local compose_file_args="-f $MAIN_COMPOSE_IMAGE"
  if [ "$mode" = "source" ]; then
    if [ ! -f "$MAIN_COMPOSE_SOURCE" ]; then
      echo "[ERROR] $MAIN_COMPOSE_SOURCE not found. Cannot run uninstall in --source mode." >&2
      exit 1
    fi
    compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_SOURCE"
    echo "[INFO] Uninstalling services in SOURCE mode."
  else
    if [ "$use_cn" = true ]; then
      compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_CN"
      echo "[INFO] Uninstalling services in IMAGE mode (China mirrors)."
    else
      echo "[INFO] Uninstalling services in IMAGE mode."
    fi
  fi

  echo "Do you want to delete all data (./data/ directory)? [y/N]"
  read -r answer
  case "$answer" in
    y|Y|yes|YES)
      echo "[INFO] Stopping services and removing images and volumes..."
      docker compose --env-file "$ENV_FILE" $compose_file_args down --rmi local -v || true
      if [ -d "data" ]; then
        echo "[INFO] Removing ./data directory..."
        rm -rf data
      fi
      ;;
    *)
      echo "[INFO] Stopping services and removing images (preserving data)..."
      docker compose --env-file "$ENV_FILE" $compose_file_args down --rmi local || true
      ;;
  esac
}

cmd_upgrade() {
  local mode=""
  local use_cn=""
  local user_provided_args=false

  # Parse command line arguments
  local temp_mode="image"
  local temp_use_cn=false

  while [ "$#" -gt 0 ]; do
    case "$1" in
      --source)
        temp_mode="source"
        user_provided_args=true
        shift
        ;;
      --cn)
        temp_use_cn=true
        user_provided_args=true
        shift
        ;;
      *)
        echo "[ERROR] Unknown argument to upgrade: $1" >&2
        usage
        exit 1
        ;;
    esac
  done

  # If user provided arguments, use them; otherwise load from config
  if [ "$user_provided_args" = true ]; then
    mode="$temp_mode"
    use_cn="$temp_use_cn"
    echo "[INFO] Using user-provided parameters for upgrade"
    # Save the new configuration
    save_install_mode "$mode" "$use_cn"
  else
    # Load saved configuration
    echo "[INFO] Loading saved install mode configuration..."
    read -r mode use_cn <<< "$(load_install_mode)"
  fi

  # Set global flag for CN mirror
  if [ "$use_cn" = "true" ]; then
    USE_CN_MIRROR=true
  fi

  ensure_env_files

  # Determine compose file arguments
  local compose_file_args="-f $MAIN_COMPOSE_IMAGE"
  if [ "$mode" = "source" ]; then
    if [ ! -f "$MAIN_COMPOSE_SOURCE" ]; then
      echo "[ERROR] $MAIN_COMPOSE_SOURCE not found. Cannot run in --source mode." >&2
      exit 1
    fi
    compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_SOURCE"
    echo "[INFO] Upgrade mode: SOURCE (building from local repos)"
  else
    if [ "$use_cn" = "true" ]; then
      compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_CN"
      echo "[INFO] Upgrade mode: IMAGE (pulling from Alibaba Cloud ACR)"
    else
      echo "[INFO] Upgrade mode: IMAGE (pulling from GHCR)"
    fi
  fi

  # Upgrade flow based on mode
  if [ "$mode" = "source" ]; then
    echo ""
    echo "========================================="
    echo "  SOURCE MODE UPGRADE"
    echo "========================================="
    echo ""

    # Step 1: Pull latest code
    echo "[INFO] Step 1/5: Pulling latest code from git..."
    if [ "$use_cn" = "true" ]; then
      echo "[INFO] Using Gitee mirrors for git operations"
      # Update submodules from Gitee if needed
      git pull || echo "[WARN] git pull failed, continuing with existing code"
    else
      git pull || echo "[WARN] git pull failed, continuing with existing code"
    fi

    # Update submodules
    if [ -f ".gitmodules" ]; then
      echo "[INFO] Updating git submodules..."
      git submodule update --init --recursive || echo "[WARN] Submodule update failed"
    fi

    # Step 2: Rebuild images
    echo ""
    echo "[INFO] Step 2/5: Rebuilding Docker images from source..."
    docker compose --env-file "$ENV_FILE" $compose_file_args build

    # Step 3: Stop current services
    echo ""
    echo "[INFO] Step 3/5: Stopping current services..."
    docker compose --env-file "$ENV_FILE" $compose_file_args down

    # Step 4: Start services with new images
    echo ""
    echo "[INFO] Step 4/5: Starting services with new images..."
    docker compose --env-file "$ENV_FILE" $compose_file_args up -d postgres redis kafka wukongim

    wait_for_postgres "$compose_file_args"

    # Step 5: Run database migrations
    echo ""
    echo "[INFO] Step 5/5: Running database migrations..."
    docker compose --env-file "$ENV_FILE" $compose_file_args run --rm tgo-rag alembic upgrade head
    docker compose --env-file "$ENV_FILE" $compose_file_args run --rm tgo-ai alembic upgrade head
    docker compose --env-file "$ENV_FILE" $compose_file_args run --rm tgo-api alembic upgrade head
    docker compose --env-file "$ENV_FILE" $compose_file_args run --rm -e PYTHONPATH=. tgo-platform alembic upgrade head

    # Start all services
    echo ""
    echo "[INFO] Starting all services..."
    docker compose --env-file "$ENV_FILE" $compose_file_args up -d

  else
    echo ""
    echo "========================================="
    echo "  IMAGE MODE UPGRADE"
    echo "========================================="
    echo ""

    # Step 1: Pull latest images
    echo "[INFO] Step 1/5: Pulling latest Docker images..."
    if [ "$use_cn" = "true" ]; then
      echo "[INFO] Pulling from Alibaba Cloud ACR..."
    else
      echo "[INFO] Pulling from GitHub Container Registry..."
    fi
    docker compose --env-file "$ENV_FILE" $compose_file_args pull

    # Step 2: Stop current services
    echo ""
    echo "[INFO] Step 2/5: Stopping current services..."
    docker compose --env-file "$ENV_FILE" $compose_file_args down

    # Step 3: Start infrastructure services
    echo ""
    echo "[INFO] Step 3/5: Starting infrastructure services..."
    docker compose --env-file "$ENV_FILE" $compose_file_args up -d postgres redis kafka wukongim

    wait_for_postgres "$compose_file_args"

    # Step 4: Run database migrations
    echo ""
    echo "[INFO] Step 4/5: Running database migrations..."
    docker compose --env-file "$ENV_FILE" $compose_file_args run --rm tgo-rag alembic upgrade head
    docker compose --env-file "$ENV_FILE" $compose_file_args run --rm tgo-ai alembic upgrade head
    docker compose --env-file "$ENV_FILE" $compose_file_args run --rm tgo-api alembic upgrade head
    docker compose --env-file "$ENV_FILE" $compose_file_args run --rm -e PYTHONPATH=. tgo-platform alembic upgrade head

    # Step 5: Start all services
    echo ""
    echo "[INFO] Step 5/5: Starting all services..."
    docker compose --env-file "$ENV_FILE" $compose_file_args up -d
  fi

  echo ""
  echo "========================================="
  echo "  ✅ UPGRADE COMPLETE"
  echo "========================================="
  echo ""
  echo "Upgrade summary:"
  echo "  • Mode: $([ "$mode" = "source" ] && echo "SOURCE (built from local code)" || echo "IMAGE (pulled from registry)")"
  echo "  • Registry: $([ "$use_cn" = "true" ] && echo "Alibaba Cloud ACR (China)" || echo "GitHub Container Registry")"
  echo "  • Configuration saved to: $CONFIG_FILE"
  echo ""
  echo "Use 'docker compose ps' to check service status."
  echo "Use 'docker compose logs -f <service>' to view logs."
}

cmd_service() {
  local sub=${1:-}
  shift || true

  local mode="image"
  local use_cn=false

  # Parse arguments (support --source and --cn in any order)
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --source)
        mode="source"
        shift
        ;;
      --cn)
        use_cn=true
        USE_CN_MIRROR=true
        shift
        ;;
      *)
        echo "[ERROR] Unknown argument to service: $1" >&2
        usage
        exit 1
        ;;
    esac
  done

  local compose_file_args="-f $MAIN_COMPOSE_IMAGE"
  if [ "$mode" = "source" ]; then
    if [ ! -f "$MAIN_COMPOSE_SOURCE" ]; then
      echo "[ERROR] $MAIN_COMPOSE_SOURCE not found. Cannot run service in --source mode." >&2
      exit 1
    fi
    compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_SOURCE"
  elif [ "$use_cn" = true ]; then
    compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_CN"
  fi

  case "$sub" in
    start)
      ensure_env_files
      echo "[INFO] Starting all core services (mode: $mode)..."
      docker compose --env-file "$ENV_FILE" $compose_file_args up -d
      ;;
    stop)
      ensure_env_files
      echo "[INFO] Stopping all core services (mode: $mode)..."
      docker compose --env-file "$ENV_FILE" $compose_file_args down
      ;;
    remove)
      ensure_env_files
      echo "[INFO] Stopping services and removing images (mode: $mode)..."
      docker compose --env-file "$ENV_FILE" $compose_file_args down --rmi local
      ;;
    *)
      echo "[ERROR] Unknown service subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

cmd_tools() {
  local sub=${1:-}
  if [ ! -f "$TOOLS_COMPOSE" ]; then
    echo "[ERROR] $TOOLS_COMPOSE not found in repository root." >&2
    exit 1
  fi
  case "$sub" in
    start)
      echo "[INFO] Starting debug tools (kafka-ui, adminer)..."
      docker compose -f "$TOOLS_COMPOSE" up -d
      ;;
    stop)
      echo "[INFO] Stopping debug tools (kafka-ui, adminer)..."
      docker compose -f "$TOOLS_COMPOSE" down
      ;;
    *)
      echo "[ERROR] Unknown tools subcommand: $sub" >&2
      usage
      exit 1
      ;;
  esac
}

cmd_build() {
  ensure_env_files

  local mode="image"
  local use_cn=false

  # Parse arguments (support --source and --cn in any order)
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --source)
        mode="source"
        shift
        ;;
      --cn)
        use_cn=true
        USE_CN_MIRROR=true
        shift
        ;;
      -*)
        echo "[ERROR] Unknown option: $1" >&2
        usage
        exit 1
        ;;
      *)
        # This is the service name, stop parsing options
        break
        ;;
    esac
  done

  if [ "$mode" != "source" ]; then
    echo "[ERROR] build is only supported in --source mode (local builds)." >&2
    echo "Usage: ./tgo.sh build --source [--cn] <service>" >&2
    exit 1
  fi

  local target=${1-}
  if [ -z "$target" ]; then
    echo "[ERROR] Missing service name for build." >&2
    usage
    exit 1
  fi
  shift || true

  if [ "$#" -gt 0 ]; then
    echo "[ERROR] Too many arguments for build." >&2
    usage
    exit 1
  fi

  case "$target" in
    api) services=(tgo-api) ;;
    rag) services=(tgo-rag tgo-rag-worker tgo-rag-beat tgo-rag-flower) ;;
    ai) services=(tgo-ai) ;;
    platform) services=(tgo-platform) ;;
    web) services=(tgo-web) ;;
    widget) services=(tgo-widget-app) ;;
    all) services=() ;;
    *)
      echo "[ERROR] Unknown service: $target" >&2
      echo "Supported: api, rag, ai, platform, web, widget, all" >&2
      exit 1
      ;;
  esac

  if [ ! -f "$MAIN_COMPOSE_SOURCE" ]; then
    echo "[ERROR] $MAIN_COMPOSE_SOURCE not found. Cannot build from source." >&2
    exit 1
  fi

  local compose_file_args="-f $MAIN_COMPOSE_IMAGE -f $MAIN_COMPOSE_SOURCE"

  if [ "${#services[@]}" -eq 0 ]; then
    echo "[INFO] Rebuilding all services from source..."
    docker compose --env-file "$ENV_FILE" $compose_file_args build
    docker compose --env-file "$ENV_FILE" $compose_file_args up -d
  else
    echo "[INFO] Rebuilding services from source: ${services[*]}..."
    docker compose --env-file "$ENV_FILE" $compose_file_args build "${services[@]}"
    docker compose --env-file "$ENV_FILE" $compose_file_args up -d "${services[@]}"
  fi
}

cmd_config() {
  local domain_config_file="./data/.tgo-domain-config"
  local subcommand=${1:-show}
  shift || true

  # Ensure data directory exists
  mkdir -p "$(dirname "$domain_config_file")"

  case "$subcommand" in
    web_domain)
      if [ $# -eq 0 ]; then
        echo "[ERROR] Domain value required"
        exit 1
      fi
      local domain="$1"
      ensure_domain_config
      sed -i.bak "s|^WEB_DOMAIN=.*|WEB_DOMAIN=$domain|" "$domain_config_file"
      rm -f "$domain_config_file.bak"
      echo "[INFO] Web domain set to: $domain"
      regenerate_nginx_config
      ;;
    widget_domain)
      if [ $# -eq 0 ]; then
        echo "[ERROR] Domain value required"
        exit 1
      fi
      local domain="$1"
      ensure_domain_config
      sed -i.bak "s|^WIDGET_DOMAIN=.*|WIDGET_DOMAIN=$domain|" "$domain_config_file"
      rm -f "$domain_config_file.bak"
      echo "[INFO] Widget domain set to: $domain"
      regenerate_nginx_config
      ;;
    api_domain)
      if [ $# -eq 0 ]; then
        echo "[ERROR] Domain value required"
        exit 1
      fi
      local domain="$1"
      ensure_domain_config
      sed -i.bak "s|^API_DOMAIN=.*|API_DOMAIN=$domain|" "$domain_config_file"
      rm -f "$domain_config_file.bak"
      echo "[INFO] API domain set to: $domain"
      regenerate_nginx_config
      ;;
    ssl_mode)
      if [ $# -eq 0 ]; then
        echo "[ERROR] SSL mode required (auto|manual|none)"
        exit 1
      fi
      local mode="$1"
      if [[ ! "$mode" =~ ^(auto|manual|none)$ ]]; then
        echo "[ERROR] Invalid SSL mode: $mode (must be auto, manual, or none)"
        exit 1
      fi
      ensure_domain_config
      sed -i.bak "s|^SSL_MODE=.*|SSL_MODE=$mode|" "$domain_config_file"
      rm -f "$domain_config_file.bak"
      echo "[INFO] SSL mode set to: $mode"
      ;;
    ssl_email)
      if [ $# -eq 0 ]; then
        echo "[ERROR] Email value required"
        exit 1
      fi
      local email="$1"
      ensure_domain_config
      sed -i.bak "s|^SSL_EMAIL=.*|SSL_EMAIL=$email|" "$domain_config_file"
      rm -f "$domain_config_file.bak"
      echo "[INFO] SSL email set to: $email"
      ;;
    ssl_manual)
      if [ $# -lt 2 ]; then
        echo "[ERROR] Usage: ./tgo.sh config ssl_manual <cert_file> <key_file> [domain]"
        exit 1
      fi
      local cert_file="$1"
      local key_file="$2"
      local domain="${3:-}"

      if [ ! -f "$cert_file" ] || [ ! -f "$key_file" ]; then
        echo "[ERROR] Certificate or key file not found"
        exit 1
      fi

      ensure_domain_config

      # If domain not specified, use all configured domains
      if [ -z "$domain" ]; then
        source "$domain_config_file" 2>/dev/null || true
        for d in "$WEB_DOMAIN" "$WIDGET_DOMAIN" "$API_DOMAIN"; do
          [ -z "$d" ] && continue
          copy_manual_cert "$cert_file" "$key_file" "$d"
        done
      else
        copy_manual_cert "$cert_file" "$key_file" "$domain"
      fi

      sed -i.bak "s/^SSL_MODE=.*/SSL_MODE=manual/" "$domain_config_file"
      echo "[INFO] Manual SSL certificates installed"
      ;;
    setup_letsencrypt)
      ensure_domain_config
      source "$domain_config_file" 2>/dev/null || true

      if [ -z "$WEB_DOMAIN" ] || [ -z "$WIDGET_DOMAIN" ] || [ -z "$API_DOMAIN" ]; then
        echo "[ERROR] All domains must be configured first"
        echo "[INFO] Run: ./tgo.sh config web_domain <domain>"
        exit 1
      fi

      local email="${SSL_EMAIL:-admin@example.com}"
      echo "[INFO] Setting up Let's Encrypt certificates..."
      bash ./scripts/setup-ssl.sh "$WEB_DOMAIN" "$WIDGET_DOMAIN" "$API_DOMAIN" "$email"

      sed -i.bak "s|^SSL_MODE=.*|SSL_MODE=auto|" "$domain_config_file"
      rm -f "$domain_config_file.bak"
      echo "[INFO] SSL mode set to: auto"
      ;;
    apply)
      if [ ! -f "$domain_config_file" ]; then
        echo "[ERROR] No domain configuration found"
        exit 1
      fi
      regenerate_nginx_config
      echo "[INFO] Nginx configuration applied"
      ;;
    show)
      if [ ! -f "$domain_config_file" ]; then
        echo "[INFO] No domain configuration found"
        echo "[INFO] Run: ./tgo.sh config web_domain <domain> to get started"
        exit 0
      fi
      echo "[INFO] Current domain configuration:"
      cat "$domain_config_file"
      ;;
    *)
      echo "[ERROR] Unknown config subcommand: $subcommand"
      echo "Usage: ./tgo.sh config <subcommand> [args]"
      echo ""
      echo "Subcommands:"
      echo "  web_domain <domain>           Set web service domain"
      echo "  widget_domain <domain>        Set widget service domain"
      echo "  api_domain <domain>           Set API service domain"
      echo "  ssl_mode <auto|manual|none>   Set SSL mode"
      echo "  ssl_email <email>             Set Let's Encrypt email"
      echo "  ssl_manual <cert> <key> [domain]  Install manual SSL certificate"
      echo "  setup_letsencrypt             Setup Let's Encrypt certificates"
      echo "  apply                         Regenerate Nginx configuration"
      echo "  show                          Show current configuration"
      exit 1
      ;;
  esac
}

# Helper function to ensure domain config file exists
ensure_domain_config() {
  local domain_config_file="./data/.tgo-domain-config"
  if [ ! -f "$domain_config_file" ]; then
    cat > "$domain_config_file" << 'EOF'
# TGO Domain Configuration
# Auto-generated by ./tgo.sh config

WEB_DOMAIN=
WIDGET_DOMAIN=
API_DOMAIN=
SSL_MODE=none
SSL_EMAIL=
ENABLE_SSL_AUTO_RENEW=true
EOF
    echo "[INFO] Created domain configuration file: $domain_config_file"
  fi
}

# Helper function to copy manual SSL certificates
copy_manual_cert() {
  local cert_file="$1"
  local key_file="$2"
  local domain="$3"

  local ssl_dir="./data/nginx/ssl/$domain"
  mkdir -p "$ssl_dir"

  cp "$cert_file" "$ssl_dir/cert.pem"
  cp "$key_file" "$ssl_dir/key.pem"

  echo "[INFO] Certificate installed for: $domain"
}

# Helper function to regenerate Nginx configuration
regenerate_nginx_config() {
  if [ ! -f "./scripts/generate-nginx-config.sh" ]; then
    echo "[WARN] Nginx config generator not found"
    return
  fi

  bash ./scripts/generate-nginx-config.sh || {
    echo "[WARN] Failed to regenerate Nginx configuration"
  }
}

main() {
  local cmd=${1:-help}
  shift || true
  case "$cmd" in
    help|-h|--help) usage ;;
    install) cmd_install "$@" ;;
    upgrade) cmd_upgrade "$@" ;;
    uninstall) cmd_uninstall "$@" ;;
    service) cmd_service "$@" ;;
    tools) cmd_tools "$@" ;;
    build) cmd_build "$@" ;;
    config) cmd_config "$@" ;;
    *)
      echo "[ERROR] Unknown command: $cmd" >&2
      usage
      exit 1
      ;;
  esac
}

main "$@"

